{
  "1. Let f(n) = n^2, g(n) = n log n, h(n) = sin(n). Which of the following statements is true? There may be more than one correct answer.\n": {
    "f = Θ(g).": false,
    "h = o(g).": true,
    "f = Ω(h).": true,
    "h = O(g).": true
  },

  "2. A recursive program satisfies equation T (n) = 9T (n/3) + Θ(n^2). What can we say about T (n)? There may be several correct answers.\n": {
    "T (n) = O(n log n)": false,
    "T (n) = Ω(n^2).": true,
    "T (n) = Θ(n^2).": false,
    "T (n) = O(n^3).": true
  },

  "3. In which of the following data structures does searching an item have worst-case complexity Θ(log n)? There may be more than one.\n": {
    "Linked lists.": false,
    "Heaps.": false,
    "Red-black trees, ": true,
    "Splay trees": false
  },

  "4. Which binary tree traversal can be used to list all numbers in a binary search tree in sorted order? There may be more than one correct answer.\n": {
    "Breadth-first search.": false,
    "Preorder.": false,
    "Inorder.": true,
    "Postorder.": false
  },

  "5. Which of the following sorting methods is not a comparison-based sort? There may be more than one right answer.\n": {
    "Quicksort.": false,
    "Radix Sort.": true,
    "Insertion Sort": false,
    "HeapSort.": false
  },
  
  "6. Which of the following problems has an easy algorithm with complexity O(n log n)? There may be more than one right answer\n":{
    "Given a list L of n integers, find three numbers x, y, z ∈ L (if they exist) such that x + y = z": false,
    "Given a list L of n integers and a target value z, find two numbers in x, y ∈ L (if they exist) such that x + y = z.": true,
    "Given a list L of n integers and a target value z, find two numbers in x, y ∈ L (if they exist) such that x - y = z.": true,
    "Given a list L of n integers, find three numbers x, y, z ∈ L (if they exist) such that x + y + z = 0.": false
  },

  "7. Which of the following algorithms correctly computes the length of a longest increasing subse-quence problem and has complexity O(n^2) ?\n There may be more than one right answer.\n": {
    "Put the numbers in the list in piles of decreasing numbers. A new number is added greedily to the first pile it can be added to, or starts a new pile if it cannot be added to any existing pile. The length of the LIS is the number of piles": true,
    "We run a greedy algorithm, maintaining a list of increasing numbers. When processing a new number we add it to the LIS if possible, we discard it and proceed otherwise.": false,
    "We run a backtracking algorithm, maintaining the list of the biggest LIS seen so far. When encountering a new number we add it to the sequence if possible. If not we backtrack and continue with the next sequence.": false,
    "We solve the problem by dynamic programming, computing the length of the LIS subsequence ending in a given term a_k of the sequence. We then take the maximum of the so-computed LIS's.": true
  },

  "8. We are given a list of courses, each with a start and an end time. We only have one room and want to schedule as many of these courses as possible.\n  Which of the following algorithms finds an optimal solution? There may be more than one correct answer.\n": {
    "Greedily choose the shortest courses.": false,
    "Greedily choose courses that start first.": false,
    "Greedily choose courses that end first.": true,
    "Sort courses by their endtime. Compute: for each course Ck, a longest sequence of courses that ends with Ck. Take the best such sequence over all k's.": true
  },

  "9. A recursive algorithm reduces solving the problem on inputs of size n to solving four subproblems on size n/2 and then combining the results.\n  The combining step takes f (n) steps.\n  We want our algorithm to have complexity O(n^2).\n  Which of the following are acceptable complexities for the combining step? There may be several right answers.\n": {
    "f (n) = O(1).": true,
    "f (n) = O(n).": true,
    "f (n) = O(n log n).": true,
    "f (n) = Θ(n^2).": false
  },

  "10. What is the complexity of inserting a new item in a sorted linked list of integers, such that the list remains sorted?\n": {
    "O(1).": false,
    "Θ(1).": false,
    "O(n).": true,
    "Θ(log n).": false
  },

  "11. What data structure can we use to implement an iterative pre-order tree traversal?\n": {
    "Queue": false,
    "Stack": true,
    "Hash Table": false,
    "Red-black tree": false
  },

  "12. What is the complexity of computing the median ?\n": {
    "Θ(n).": true,
    "Θ(n log n).": false,
    "Θ(1)": false,
    "Θ(n^2).": false
  },

  "13. In a red-black tree which of the following is not necessarily true? There may be several correct answers.\n": {
    "The root is red.": true,
    "The root is black.": false,
    "Every path from the root to leaves has the same number of red nodes.": true,
    "A black parent can only have red children.": true
  },

  "14. Which of the following is correct? There may be several correct answers.\n":{
    "The worst-case complexity of insert, delete, search operations in a binary search tree is O(log n).": false,
    "The worst-case complexity of insert, delete, search operations in an AVL tree is O(log n).": true,
    "The worst-case complexity of insert, delete, search operations in a splay tree is O(log n).": false,
    "The worst-case complexity of insert, delete, search operations in a red-black tree is O(log n).": true
  },

  "15. Which of the following sorting algorithm is not subject to the Ω(n log n) lower bound for sorting?\n": {
    "Counting sort.": true,
    "Heapsort.": false,
    "Radix Sort.": true,
    "MergeSort.": false
  },

  "16. Consider two strings A = 'abcca' and B = 'abacbcaa'.\n  Let x be the length of the longest common subsequence (not necessarily contiguous) between A and B and let y be the number of such longest common subsequences between A and B.\n  Then x + 100y = . . ..\n": {
    "304": false,
    "305": false,
    "405": false,
    "205": true
  },

  "17. Suppose we sort n ≥ 3 values using quicksort, and after the first pivoting there are equally many numbers on the left of the pivot as they are on the right.\n Which of the following are true? There may be multiple answers.\n": {
    "All the elements could have been the pivot.": false,
    "The pivot is the median": true,
    "The pivot is not the maximum.": true,
    "none of the other statements": false
  },

  "18. What is the second operation needed for inserting a value x at the front of a singly linked list? We assume the list is represented by one pointer head only.\n": {
    "allocate a node with the value x.": false,
    "x.next = head.": true,
    "head.prev = x": false,
    "head = x.": false,
    "none of the other options.": false
  },

  "19. A binary min-heap is a data structure which models an almost complete binary tree which has\n  the heap property: For every node N with a parent P, the key of P is smaller than the key of\n  N. The array-based implementation of a binary min-heap with n nodes is an array A[0..2m − 1]\n  with two extra attributes: the capacity A.length = 2m − 1 and the size A.size = n, such that\n  A.size ≤ A.length. The elements in the nodes of the binary min-heap are stored in the first n\n  elements of A: the root is stored in A[0], and if N is the left (resp. right) child of a node P stored\n  in A[i] then N is stored in A[2 · i + 1] (resp. A[2 · i + 2]).\n\n   For 0 ≤ i, j < n we define the relation grandpa(i, j) if A[j] stores the parent of the parent of A[i].\n   What is the formula which defines the relation grandpa(i, j) in a binary min-heap ?\n": {
    "(4 · j + 3 ≤ i) ∧ (i ≤ 4 · j + 6)": true,
    "(4 · i + 3 ≤ j) ∧ (j ≤ 4 · i + 6)": false,
    "j = ⌊i/4⌋.": false,
    "(4 · j + 1 ≤ i) ∧ (i ≤ 4 · j + 2)": false
  },

  "20. A binary min-heap is a data structure which models an almost complete binary tree which has\n  the heap property: For every node N with a parent P, the key of P is smaller than the key of\n  N. The array-based implementation of a binary min-heap with n nodes is an array A[0..2m − 1]\n  with two extra attributes: the capacity A.length = 2m − 1 and the size A.size = n, such that\n  A.size ≤ A.length. The elements in the nodes of the binary min-heap are stored in the first n\n  elements of A: the root is stored in A[0], and if N is the left (resp. right) child of a node P stored\n  in A[i] then N is stored in A[2 · i + 1] (resp. A[2 · i + 2]).\n\n   What is the maximum number of nodes in a binary min-heap with depth h ?\n": {
    "2^(h+1) - 1": true,
    "2^h": false,
    "h^2 - 1": false,
    "2^(h-1) + 1": false
  },

  "21. A binary min-heap is a data structure which models an almost complete binary tree which has\n  the heap property: For every node N with a parent P, the key of P is smaller than the key of\n  N. The array-based implementation of a binary min-heap with n nodes is an array A[0..2m − 1]\n  with two extra attributes: the capacity A.length = 2m − 1 and the size A.size = n, such that\n  A.size ≤ A.length. The elements in the nodes of the binary min-heap are stored in the first n\n  elements of A: the root is stored in A[0], and if N is the left (resp. right) child of a node P stored\n  in A[i] then N is stored in A[2 · i + 1] (resp. A[2 · i + 2]).\n\n   (i) If A is a binary min-heap then A is sorted in the ascending order of the keys from its nodes? True/False \n  (ii) If A is sorted in the ascending order of the keys from its nodes then A is a binary min-heap? True/False\n": {
    "(i) True (ii) False": false,
    "(i) False (ii) True": true,
    "(i) False (ii) False": false,
    "(i) True (ii) True": false
  },

  "22. A binary min-heap is a data structure which models an almost complete binary tree which has\n  the heap property: For every node N with a parent P, the key of P is smaller than the key of\n  N. The array-based implementation of a binary min-heap with n nodes is an array A[0..2m − 1]\n  with two extra attributes: the capacity A.length = 2m − 1 and the size A.size = n, such that\n  A.size ≤ A.length. The elements in the nodes of the binary min-heap are stored in the first n\n  elements of A: the root is stored in A[0], and if N is the left (resp. right) child of a node P stored\n  in A[i] then N is stored in A[2 · i + 1] (resp. A[2 · i + 2]).\n\n   For 0 ≤ i, j < n we define the relation grandpa(i, j) if A[j] stores the parent of the parent of A[i].\n   What is the runtime complexity of the deletion of the node with minimum key from a binary min-heap with n nodes?\n": {
    "O(log n)": true,
    "O(1)": false,
    "Θ(n log n)": false,
    "Θ(n)": false
  }

}